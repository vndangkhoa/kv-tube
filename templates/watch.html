{% extends "layout.html" %}

{% block content %}
<!-- Artplayer -->
<script src="https://cdn.jsdelivr.net/npm/artplayer/dist/artplayer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<div class="yt-watch-layout">
    <!-- Player Section -->
    <div class="yt-player-section">
        <div class="yt-player-container">
            <div id="artplayer-app" style="width: 100%; height: 100%;"></div>
            <!-- Loading State (Confined to Player) -->
            <div id="loading" class="yt-loader"></div>

        </div>
        <!-- Placeholder for Mini Mode -->
        <div id="playerPlaceholder" class="yt-player-placeholder"></div>

        <!-- Info Skeleton -->
        <div id="infoSkeleton" style="margin-top:20px;">
            <div class="skeleton-line skeleton" style="width:70%; height:28px; margin-bottom:16px;"></div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                <div style="display:flex; align-items:center; gap:12px;">
                    <div class="skeleton-avatar skeleton"></div>
                    <div class="skeleton-line skeleton" style="width:120px; margin:0;"></div>
                </div>
                <div class="skeleton-line skeleton" style="width:250px; height:36px; border-radius:18px;"></div>
            </div>
            <div class="skeleton-block skeleton" style="height:100px; border-radius:12px;"></div>
        </div>

        <!-- Video Info -->
        <div class="yt-video-info" id="videoInfo" style="display:none;">
            <h1 id="videoTitle">Loading...</h1>

            <!-- Actions -->
            <div class="yt-video-actions">
                <button class="yt-action-btn" id="shareBtn">
                    <i class="fas fa-share"></i>
                    Share
                </button>
                <button class="yt-action-btn" id="downloadBtn" onclick="showDownloadModal(currentVideoData.id)">
                    <i class="fas fa-download"></i>
                    Download
                </button>
                <button class="yt-action-btn" id="saveBtn" onclick="toggleSaveToLibrary()">
                    <i class="far fa-bookmark"></i>
                    Save
                </button>
                <button class="yt-action-btn" id="loopBtn" onclick="toggleLoop(this)">
                    <i class="fas fa-redo"></i>
                    Loop
                </button>
                <button class="yt-action-btn" id="queueBtn" onclick="addToQueue()" style="position:relative;">
                    <i class="fas fa-list-ul"></i>
                    Queue
                    <span id="queueBadge" class="queue-badge" style="display:none;">0</span>
                </button>


                <!-- View Mode Buttons -->
                <div class="view-mode-buttons">
                    <button class="view-mode-btn" id="defaultModeBtn" onclick="setViewMode('default')"
                        title="Default View">
                        <i class="fas fa-columns"></i>
                    </button>
                    <button class="view-mode-btn active" id="theaterModeBtn" onclick="setViewMode('theater')"
                        title="Theater Mode">
                        <i class="fas fa-expand-alt"></i>
                    </button>
                    <button class="view-mode-btn" id="pipModeBtn" onclick="togglePiP()" title="Picture-in-Picture">
                        <i class="fas fa-external-link-square-alt"></i>
                    </button>
                    <button class="view-mode-btn" id="fullscreenBtn" onclick="toggleFullscreen()" title="Fullscreen">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>


            <!-- Summary Box (Hidden by default) -->
            <!-- Summary Box removed -->

            <!-- Channel Info -->
            <div class="yt-channel-info">
                <div class="yt-channel-details">
                    <div class="yt-channel-avatar-lg" id="channelAvatar">
                        <span id="channelAvatarLetter"></span>
                    </div>
                    <div>
                        <p style="font-weight: 500;" id="channelName">Loading...</p>
                        <p class="yt-video-stats" id="viewCount">0 views</p>
                    </div>
                </div>
                <button class="yt-subscribe-btn" id="subscribeBtn" onclick="toggleSubscribe()">Subscribe</button>
            </div>

            <!-- Description -->
            <div class="yt-description-box" id="descriptionBox" onclick="toggleDescription()">
                <p class="yt-description-stats" id="descStats"></p>
                <p class="yt-description-text" id="videoDesc">Loading description...</p>
            </div>

            <!-- Comments Section (Collapsible) -->
            <div class="yt-comments-section" id="commentsSection">
                <button class="yt-comments-toggle" id="commentsToggle" onclick="toggleComments()">
                    <div class="yt-comments-preview">
                        <span id="commentCountDisplay">Comments</span>
                        <i class="fas fa-chevron-down" id="commentsChevron"></i>
                    </div>
                </button>
                <div class="yt-comments-content" id="commentsContent" style="display: none;">
                    <div class="yt-comments-header">
                        <h3><span id="commentCount">0</span> Comments</h3>
                    </div>
                    <div class="yt-comments-list" id="commentsList">
                        <!-- Comments loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Sidebar -->
    <!-- Right Sidebar -->
    <div class="yt-watch-sidebar">
        <!-- Queue Section (Collapsible Dropdown) -->
        <div id="queueSection" class="yt-queue-dropdown">
            <div class="yt-queue-dropdown-header" onclick="toggleQueueDropdown()">
                <span><i class="fas fa-list-ol"></i> Queue (<span id="queueCount">0</span>)</span>
                <i class="fas fa-chevron-down" id="queueDropdownChevron"></i>
            </div>
            <div class="yt-queue-dropdown-content" id="queueDropdownContent">
                <div id="queueList">
                    <!-- Queue items rendered here -->
                </div>
            </div>
        </div>

        <!-- Suggested Videos -->
        <div class="yt-suggested" id="relatedVideos">
            <h3 style="margin-bottom: 16px; font-size: 16px;">Related Videos</h3>
            <!-- Skeleton Items for Related -->
            <div class="skeleton-related-item" style="display:flex; gap:8px; margin-bottom:12px;">
                <div class="skeleton" style="width:140px; aspect-ratio:16/9; border-radius:8px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div class="skeleton-line skeleton" style="width:90%; height:14px; margin-bottom:6px;"></div>
                    <div class="skeleton-line skeleton" style="width:60%; height:12px;"></div>
                </div>
            </div>
            <div class="skeleton-related-item" style="display:flex; gap:8px; margin-bottom:12px;">
                <div class="skeleton" style="width:168px; height:94px; border-radius:8px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div class="skeleton-line skeleton" style="width:90%; height:14px; margin-bottom:6px;"></div>
                    <div class="skeleton-line skeleton" style="width:60%; height:12px;"></div>
                </div>
            </div>
            <div class="skeleton-related-item" style="display:flex; gap:8px; margin-bottom:12px;">
                <div class="skeleton" style="width:168px; height:94px; border-radius:8px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div class="skeleton-line skeleton" style="width:90%; height:14px; margin-bottom:6px;"></div>
                    <div class="skeleton-line skeleton" style="width:60%; height:12px;"></div>
                </div>
            </div>
            <div class="skeleton-related-item" style="display:flex; gap:8px; margin-bottom:12px;">
                <div class="skeleton" style="width:168px; height:94px; border-radius:8px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div class="skeleton-line skeleton" style="width:90%; height:14px; margin-bottom:6px;"></div>
                    <div class="skeleton-line skeleton" style="width:60%; height:12px;"></div>
                </div>
            </div>
            <div class="skeleton-related-item" style="display:flex; gap:8px; margin-bottom:12px;">
                <div class="skeleton" style="width:140px; aspect-ratio:16/9; border-radius:8px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div class="skeleton-line skeleton" style="width:90%; height:14px; margin-bottom:6px;"></div>
                    <div class="skeleton-line skeleton" style="width:60%; height:12px;"></div>
                </div>
            </div>
            <!-- Sentinel for Infinite Scroll -->
            <div id="relatedSentinel" style="height: 20px; margin-top: 10px;"></div>
        </div>
    </div>

    <!-- Watch page styles extracted to external file for better caching -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modules/watch.css') }}">

    <link rel="stylesheet" href="{{ url_for('static', filename='css/modules/downloads.css') }}">

    <!-- HLS Support (Local) -->
    <script src="/static/js/hls.min.js"></script>

    <script>
        var commentsLoaded = false;
        // Current video data for Queue/History/Saved - Populated by JS or Server
        var currentVideoData = {
            id: "{{ request.args.get('v') }}",
            title: document.title.replace(' - KV-Tube', ''), // Initial fallback
            thumbnail: "", // Will be updated by Artplayer or API
            uploader: ""
        };

        // Initialize immediately from URL params for instant feedback
        (function hydrateFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const title = urlParams.get('title');
            const uploader = urlParams.get('uploader');
            const thumbnail = urlParams.get('thumbnail');

            if (title) {
                currentVideoData.title = title;
                document.title = title + ' - KV-Tube';
                const titleEl = document.getElementById('videoTitle');
                if (titleEl) {
                    titleEl.innerText = title;
                    document.getElementById('videoInfo').style.display = 'block'; // Show info immediately
                    document.getElementById('infoSkeleton').style.display = 'none'; // Hide skeleton
                }
            }

            if (uploader) {
                currentVideoData.uploader = uploader;
                const channelEl = document.getElementById('channelName');
                if (channelEl) channelEl.innerText = uploader;

                // Set avatar letter
                const avatarLetter = document.getElementById('channelAvatarLetter');
                if (avatarLetter) avatarLetter.innerText = uploader.charAt(0).toUpperCase();
            }

            if (thumbnail) {
                currentVideoData.thumbnail = thumbnail;
                // Show thumbnail as placeholder in player area
                const playerContainer = document.getElementById('artplayer-app');
                if (playerContainer) {
                    playerContainer.style.backgroundImage = `url('${thumbnail}')`;
                    playerContainer.style.backgroundSize = 'cover';
                    playerContainer.style.backgroundPosition = 'center';
                }
            }
        })();

        // Rotation function removed



        // Transcription functions removed

        function initArtplayer(url, poster, subtitleUrl = '', type = 'auto') {
            // Check User Preference
            const playerPref = localStorage.getItem('kv_player_pref');
            if (playerPref === 'native') {
                return initNativePlayer(url, poster);
            }

            // --- ARTPLAYER INITIALIZATION ---
            // Store art instance globally for other functions
            window.art = null;
            // Update currentVideoData with poster (thumbnail)
            if (poster) {
                // Use stable YouTube thumbnail URL to prevent expiration of signed URLs
                currentVideoData.thumbnail = `https://i.ytimg.com/vi/${currentVideoData.id}/hqdefault.jpg`;
                // Auto-save to history now that we have the thumbnail
                setTimeout(() => {
                    const titleEl = document.getElementById('videoTitle');
                    if (titleEl && titleEl.innerText !== 'Loading...') {
                        currentVideoData.title = titleEl.innerText;
                    }
                    const uploaderEl = document.getElementById('channelName');
                    if (uploaderEl && uploaderEl.innerText !== 'Loading...') {
                        currentVideoData.uploader = uploaderEl.innerText;
                    }
                    saveToLibrary('history', currentVideoData);
                }, 2000);
            }

            // Disable direct YouTube subtitle URL to avoid CORS errors
            // We'll use our server-side /api/transcript endpoint instead


            window.art = new Artplayer({
                container: '#artplayer-app',
                url: url,
                poster: poster,
                type: type,
                volume: 0.5,
                muted: false,
                autoplay: false,
                pip: true,
                autoSize: false,
                fullscreenWeb: true,
                miniProgressBar: true,
                mutex: true,
                backdrop: true,
                playsInline: true,
                autoPlayback: true,
                lock: true,
                fastForward: true,
                autoOrientation: true,
                theme: '#ff0000',
                autoMini: false, // Custom mini mode implemented below
                lang: navigator.language.toLowerCase(),
                moreVideoAttr: {
                    crossOrigin: 'anonymous',
                },
                controls: [
                    {
                        name: 'prev',
                        index: 10,
                        position: 'left',
                        html: '<i class="fas fa-step-backward" style="font-size: 16px;"></i>',
                        tooltip: 'Previous',
                        click: function () {
                            if (window.history.length > 1) {
                                window.history.back();
                            } else {
                                window.location.href = '/';
                            }
                        },
                    },
                    {
                        name: 'next',
                        index: 20,
                        position: 'left',
                        html: '<i class="fas fa-step-forward" style="font-size: 16px;"></i>',
                        tooltip: 'Next',
                        click: function () {
                            playNextVideo();
                        },
                    },
                ],
                customType: {
                    m3u8: function (video, url) {
                        if (Hls.isSupported()) {
                            const hls = new Hls({
                                maxBufferLength: 30,
                                maxMaxBufferLength: 60,
                                debug: false,
                            });
                            hls.loadSource(url);
                            hls.attachMedia(video);
                        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                            video.src = url;
                        } else {
                            showToast("Browser does not support HLS.", "error");
                        }
                    },
                },
                mounted: function (art) {
                    window.player = art;

                    // Ratio check
                    function checkVertical() {
                        const video = art.video;
                        if (video.videoHeight > 0 && video.videoHeight > video.videoWidth) {
                            const ratio = `${video.videoWidth}/${video.videoHeight}`;
                            art.aspectRatio = ratio;
                            art.video.style.objectFit = 'contain';
                            const container = document.querySelector('.yt-player-container');
                            if (container) {
                                container.style.aspectRatio = ratio;
                                container.style.width = '100%';
                                container.style.maxWidth = '100%';
                                if (window.innerWidth > 768) {
                                    container.style.maxWidth = '450px';
                                    container.style.margin = '0 auto';
                                }
                            }
                        }
                    }
                    checkVertical();
                    art.on('video:loadedmetadata', checkVertical);

                    // --- Custom Mini Player Logic ---
                    setupMiniPlayer();



                    // --- Auto Play Next ---
                    art.on('video:ended', () => {
                        playNextVideo();
                    });
                },
            });
            return art;
        }

        // --- NATIVE PLAYER FALLBACK ---
        function initNativePlayer(url, poster) {
            console.log("Initializing Native Player...");
            const container = document.getElementById('artplayer-app');
            container.innerHTML = ''; // Clear Artplayer

            // Apply styles to match Artplayer container
            container.style.backgroundColor = '#000';
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            container.style.justifyContent = 'center';

            // Create Video Element
            const video = document.createElement('video');
            video.controls = true;
            video.poster = poster;
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.maxHeight = '100vh';
            video.style.maxHeight = '100vh';
            video.playsInline = true;
            video.autoplay = true; // Auto Play

            container.appendChild(video);

            // Auto Play Next
            video.addEventListener('ended', () => {
                playNextVideo();
            });

            // HLS Support
            if (url.includes('.m3u8')) {
                if (Hls.isSupported()) {
                    const hls = new Hls();
                    hls.loadSource(url);
                    hls.attachMedia(video);
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = url;
                }
            } else {
                video.src = url;
            }

            // Update Global State (Shim for Artplayer)
            window.player = {
                video: video,
                play: () => video.play(),
                pause: () => video.pause(),
                destroy: () => {
                    video.pause();
                    video.src = '';
                    video.remove();
                },
                // Getter/Setter for loop shim
                get loop() { return video.loop; },
                set loop(val) { video.loop = val; }
            };

            // Update History Logic (Simplified)
            currentVideoData.thumbnail = `https://i.ytimg.com/vi/${currentVideoData.id}/hqdefault.jpg`;
            setTimeout(() => {
                const titleEl = document.getElementById('videoTitle');
                if (titleEl) currentVideoData.title = titleEl.innerText;
                const uploaderEl = document.getElementById('channelName');
                if (uploaderEl) currentVideoData.uploader = uploaderEl.innerText;
                saveToLibrary('history', currentVideoData);
            }, 2000);

            // Setup Mini Player for native video
            setupMiniPlayer();

            return window.player;
        }

        // --- Movable Mini Player Logic ---
        function setupMiniPlayer() {
            const playerContainer = document.querySelector('.yt-player-container');
            const placeholder = document.getElementById('playerPlaceholder');
            const playerSection = document.querySelector('.yt-player-section');

            // Scroll Observer
            const observer = new IntersectionObserver((entries) => {
                // If player section top is out of view (scrolling down)
                const entry = entries[0];
                if (!entry.isIntersecting && entry.boundingClientRect.top < 0) {
                    enableMiniMode();
                } else {
                    disableMiniMode();
                }
            }, { threshold: 0, rootMargin: '-100px 0px 0px 0px' }); // Trigger when header passes

            observer.observe(playerSection);

            function enableMiniMode() {
                if (playerContainer.classList.contains('yt-mini-mode')) return;
                playerContainer.classList.add('yt-mini-mode');
                placeholder.style.display = 'block';
                // Trigger reflow?
                playerContainer.style.position = 'fixed';
                playerContainer.style.bottom = '20px';
                playerContainer.style.right = '20px';
                playerContainer.style.width = '320px';
                playerContainer.style.height = '180px';
                playerContainer.style.zIndex = '9999';
                playerContainer.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                playerContainer.style.borderRadius = '12px';
            }



            function disableMiniMode() {
                if (!playerContainer.classList.contains('yt-mini-mode')) return;
                playerContainer.classList.remove('yt-mini-mode');
                placeholder.style.display = 'none';

                // Reset styles to ensure normal layout
                playerContainer.style.top = '';
                playerContainer.style.left = '';
                playerContainer.style.bottom = '';
                playerContainer.style.right = '';
                playerContainer.style.transform = '';
            }

            // Drag Logic
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            playerContainer.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            // Touch support
            playerContainer.addEventListener('touchstart', dragStart, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', dragEnd);

            function dragStart(e) {
                if (!playerContainer.classList.contains('yt-mini-mode')) return;
                // Don't drag if clicking controls (could be tricky, but basic grab works)
                // Filter out clicks on seekbar or buttons if needed, but container grab is ok usually.
                if (e.target.closest('.art-controls') || e.target.closest('.art-video')) {
                    // Allow interaction with controls, but maybe handle drag on edges/title if existed.
                    // For now, let's allow grab anywhere but maybe standard controls prevent propagation?
                    // Actually Artplayer captures clicks. We might need a specific handle or overlay.
                    // But user asked for "movable". Let's try grabbing the container directly.
                }

                // For better UX, maybe only drag when holding header or empty space?
                // Given artplayer fills it, we drag the whole thing.

                isDragging = true;

                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

                // Get current position
                const rect = playerContainer.getBoundingClientRect();
                startX = clientX;
                startY = clientY;
                initialLeft = rect.left;
                initialTop = rect.top;

                // Unset bottom/right to switch to top/left positioning for dragging
                playerContainer.style.bottom = 'auto';
                playerContainer.style.right = 'auto';
                playerContainer.style.left = initialLeft + 'px';
                playerContainer.style.top = initialTop + 'px';

                e.preventDefault(); // Prevent text selection
            }

            function drag(e) {
                if (!isDragging) return;

                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;

                let newLeft = initialLeft + dx;
                let newTop = initialTop + dy;

                // Boundaries
                const winWidth = window.innerWidth;
                const winHeight = window.innerHeight;
                const rect = playerContainer.getBoundingClientRect();

                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft + rect.width > winWidth) newLeft = winWidth - rect.width;
                if (newTop + rect.height > winHeight) newTop = winHeight - rect.height;

                playerContainer.style.left = newLeft + 'px';
                playerContainer.style.top = newTop + 'px';

                e.preventDefault();
            }

            function dragEnd() {
                isDragging = false;
            }
        } // End setupMiniPlayer

        // --- Loop Logic ---
        function toggleLoop(btn) {
            if (!window.player) {
                showToast("Player not ready yet", "error");
                return;
            }
            const isLoop = !window.player.loop;
            window.player.loop = isLoop;

            // Force style update
            if (isLoop) {
                btn.classList.add('active');
                btn.style.background = '#ff0000';
                btn.style.color = '#fff';
                btn.innerHTML = '<i class="fas fa-redo"></i> Loop On';
                showToast("Loop Mode is ON", "success");
            } else {
                btn.classList.remove('active');
                btn.style.background = '';
                btn.style.color = '';
                btn.innerHTML = '<i class="fas fa-redo"></i> Loop';
                showToast("Loop Mode is OFF");
            }
        }

        // --- Auto Play Next Logic ---
        // --- Auto Play Next Logic ---
        async function playNextVideo() {
            console.log("Video ended. Looking for next video...");
            const relatedContainer = document.getElementById('relatedVideos');
            if (!relatedContainer) return;

            // Helper to get first card
            const getNextCard = () => relatedContainer.querySelector('.yt-video-card-horizontal');

            let nextCard = getNextCard();

            if (!nextCard) {
                console.log("No related videos loaded yet. Fetching...");
                showToast("Loading next video...", "info");

                // Trigger fetch if not already loading
                if (!relatedIsLoading) {
                    await loadMoreRelated();
                } else {
                    // Wait a bit if already loading
                    await new Promise(r => setTimeout(r, 1500));
                }

                // Retry getting card
                nextCard = getNextCard();
            }

            if (nextCard) {
                console.log("Playing next video...");
                showToast("Playing next video...", "info");
                nextCard.click();
            } else {
                console.log("No related videos found even after fetch.");
                showToast("No next video found.", "info");
            }
        }

        // --- Queue Logic (Toggle) ---
        function addToQueue() {
            const btn = document.getElementById('queueBtn');
            if (!currentVideoData.id) {
                showToast("Video data not ready", "error");
                return;
            }

            let queue = JSON.parse(localStorage.getItem('kv_queue') || '[]');
            const existingIndex = queue.findIndex(v => v.id === currentVideoData.id);

            if (existingIndex !== -1) {
                // Remove from queue (toggle off)
                queue.splice(existingIndex, 1);
                localStorage.setItem('kv_queue', JSON.stringify(queue));
                showToast("Removed from Queue", "info");

                // Reset button
                if (btn) {
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.innerHTML = '<i class="fas fa-list-ul"></i> Queue';
                }
            } else {
                // Add to queue
                queue.push({
                    id: currentVideoData.id,
                    title: currentVideoData.title,
                    thumbnail: currentVideoData.thumbnail,
                    uploader: currentVideoData.uploader,
                    duration: currentVideoData.duration
                });
                localStorage.setItem('kv_queue', JSON.stringify(queue));
                showToast("Added to Queue", "success");

                // Active button
                if (btn) {
                    btn.classList.add('active');
                    btn.style.background = '#ff0000';
                    btn.style.color = '#fff';
                    btn.innerHTML = '<i class="fas fa-check"></i> In Queue';
                }
                updateQueueCount(); // Update count in dropdown
                updateQueueBadge(); // Update button badge
            }
        }

        // Check if current video is already in queue on load
        function updateQueueButtonState() {
            const btn = document.getElementById('queueBtn');
            const badge = document.getElementById('queueBadge');
            if (!btn) return;

            const queue = JSON.parse(localStorage.getItem('kv_queue') || '[]');
            const isInQueue = currentVideoData.id && queue.some(v => v.id === currentVideoData.id);

            // Update badge with total queue count
            if (badge) {
                if (queue.length > 0) {
                    badge.style.display = 'flex';
                    badge.innerText = queue.length;
                } else {
                    badge.style.display = 'none';
                }
            }

            if (isInQueue) {
                btn.classList.add('active');
                btn.style.background = '#ff0000';
                btn.style.color = '#fff';
                btn.innerHTML = '<i class="fas fa-check"></i> In Queue <span id="queueBadge" class="queue-badge" style="display:flex;">' + queue.length + '</span>';
            } else {
                btn.classList.remove('active');
                btn.style.background = '';
                btn.style.color = '';
                btn.innerHTML = '<i class="fas fa-list-ul"></i> Queue' + (queue.length > 0 ? ' <span id="queueBadge" class="queue-badge" style="display:flex;">' + queue.length + '</span>' : '');
            }
        }

        // --- Save to Library (Local Storage) ---
        // Note: Named toggleSaveToLibrary to avoid shadowing global saveToLibrary(type, item) in main.js
        function toggleSaveToLibrary() {
            const btn = document.getElementById('saveBtn');
            if (!currentVideoData.id) {
                showToast("Video data not ready", "error");
                return;
            }

            let saved = JSON.parse(localStorage.getItem('kv_saved') || '[]');
            const existingIndex = saved.findIndex(v => v.id === currentVideoData.id);

            if (existingIndex !== -1) {
                // Remove (toggle off)
                saved.splice(existingIndex, 1);
                localStorage.setItem('kv_saved', JSON.stringify(saved));
                showToast("Removed from Library", "info");

                if (btn) {
                    btn.classList.remove('active');
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.innerHTML = '<i class="far fa-bookmark"></i> Save';
                }
            } else {
                // Add
                saved.push({
                    id: currentVideoData.id,
                    title: currentVideoData.title,
                    thumbnail: currentVideoData.thumbnail,
                    uploader: currentVideoData.uploader,
                    savedAt: new Date().toISOString()
                });
                localStorage.setItem('kv_saved', JSON.stringify(saved));
                showToast("Saved to Library", "success");

                if (btn) {
                    btn.classList.add('active');
                    btn.style.background = '#ff0000';
                    btn.style.color = '#fff';
                    btn.innerHTML = '<i class="fas fa-bookmark"></i> Saved';
                }
            }
        }

        function updateSaveButtonState() {
            const btn = document.getElementById('saveBtn');
            if (!btn || !currentVideoData.id) return;

            const saved = JSON.parse(localStorage.getItem('kv_saved') || '[]');
            const isSaved = saved.some(v => v.id === currentVideoData.id);

            if (isSaved) {
                btn.classList.add('active');
                btn.style.background = '#ff0000';
                btn.style.color = '#fff';
                btn.innerHTML = '<i class="fas fa-bookmark"></i> Saved';
            }
        }

        // --- Subscribe Logic ---
        function toggleSubscribe() {
            const btn = document.getElementById('subscribeBtn');

            // Get channel info from current video data
            const channelName = document.getElementById('channelName')?.innerText || currentVideoData.uploader;
            if (!channelName || channelName === 'Loading...') {
                showToast("Channel info not ready yet", "error");
                return;
            }

            // Try to get channel ID from the avatar link or construct from name
            const avatarEl = document.getElementById('channelAvatar');
            let channelId = avatarEl?.onclick ? avatarEl.getAttribute('data-channel-id') : null;

            // If no channel ID stored, use channel name as ID (fallback)
            if (!channelId) {
                channelId = channelName.replace(/\s+/g, '');
            }

            let subscriptions = JSON.parse(localStorage.getItem('kv_subscriptions') || '[]');
            const existingIndex = subscriptions.findIndex(s => s.id === channelId || s.title === channelName);

            if (existingIndex !== -1) {
                // Unsubscribe (toggle off)
                subscriptions.splice(existingIndex, 1);
                localStorage.setItem('kv_subscriptions', JSON.stringify(subscriptions));
                showToast("Unsubscribed from " + channelName);

                if (btn) {
                    btn.classList.remove('subscribed');
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.innerHTML = 'Subscribe';
                }
            } else {
                // Subscribe
                const avatarLetter = document.getElementById('channelAvatarLetter')?.innerText || channelName.charAt(0).toUpperCase();
                subscriptions.push({
                    id: channelId,
                    title: channelName,
                    thumbnail: null, // Could be fetched from API if available
                    letter: avatarLetter
                });
                localStorage.setItem('kv_subscriptions', JSON.stringify(subscriptions));
                showToast("Subscribed to " + channelName, "success");

                if (btn) {
                    btn.classList.add('subscribed');
                    btn.style.background = 'var(--yt-bg-secondary)';
                    btn.style.color = 'var(--yt-text-secondary)';
                    btn.innerHTML = '<i class="fas fa-bell"></i> Subscribed';
                }
            }
        }

        function updateSubscribeButtonState() {
            const btn = document.getElementById('subscribeBtn');
            if (!btn) return;

            const channelName = document.getElementById('channelName')?.innerText;
            if (!channelName || channelName === 'Loading...') return;

            const subscriptions = JSON.parse(localStorage.getItem('kv_subscriptions') || '[]');
            const isSubscribed = subscriptions.some(s => s.title === channelName);

            if (isSubscribed) {
                btn.classList.add('subscribed');
                btn.style.background = 'var(--yt-bg-secondary)';
                btn.style.color = 'var(--yt-text-secondary)';
                btn.innerHTML = '<i class="fas fa-bell"></i> Subscribed';
            } else {
                btn.classList.remove('subscribed');
                btn.style.background = '';
                btn.style.color = '';
                btn.innerHTML = 'Subscribe';
            }
        }

        // --- View Mode Functions ---
        function setViewMode(mode) {
            const layout = document.querySelector('.yt-watch-layout');
            const defaultBtn = document.getElementById('defaultModeBtn');
            const theaterBtn = document.getElementById('theaterModeBtn');

            if (mode === 'default') {
                layout.classList.add('default-mode');
                defaultBtn.classList.add('active');
                theaterBtn.classList.remove('active');
            } else {
                layout.classList.remove('default-mode');
                defaultBtn.classList.remove('active');
                theaterBtn.classList.add('active');
            }

            // Save preference
            localStorage.setItem('kv_view_mode', mode);
        }

        function togglePiP() {
            const video = document.querySelector('video');
            if (!video) {
                showToast('Video not ready', 'error');
                return;
            }

            if (document.pictureInPictureElement) {
                document.exitPictureInPicture();
                document.getElementById('pipModeBtn').classList.remove('active');
            } else if (document.pictureInPictureEnabled) {
                video.requestPictureInPicture();
                document.getElementById('pipModeBtn').classList.add('active');
            } else {
                showToast('PiP not supported', 'info');
            }
        }

        function toggleFullscreen() {
            const container = document.querySelector('.yt-player-container');
            const btn = document.getElementById('fullscreenBtn');

            if (document.fullscreenElement) {
                document.exitFullscreen();
                btn.classList.remove('active');
            } else {
                container.requestFullscreen();
                btn.classList.add('active');
            }
        }

        // Initialize view mode from localStorage
        document.addEventListener('DOMContentLoaded', () => {
            // On mobile, always use theater mode for better viewing
            const isMobile = window.innerWidth <= 1024;
            const savedMode = isMobile ? 'theater' : (localStorage.getItem('kv_view_mode') || 'theater');
            setViewMode(savedMode);

            // Listen for PiP exit
            document.addEventListener('leavepictureinpicture', () => {
                document.getElementById('pipModeBtn').classList.remove('active');
            });

            // Listen for fullscreen exit
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    document.getElementById('fullscreenBtn').classList.remove('active');
                }
            });
        });

        // --- Download Video ---
        async function downloadVideo() {
            const videoId = "{{ video_id }}";
            const btn = document.getElementById('downloadBtn');

            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing...';
            btn.disabled = true;

            try {
                const response = await fetch(`/api/download?v=${videoId}`);
                const data = await response.json();

                if (data.url) {
                    // Open direct MP4 URL
                    window.open(data.url, '_blank');
                    showToast("Download started!", "success");
                } else {
                    showToast(data.error || "Could not get download link", "error");
                }
            } catch (e) {
                showToast("Download failed", "error");
            } finally {
                btn.innerHTML = '<i class="fas fa-download"></i> Download';
                btn.disabled = false;
            }
        }

        // --- Queue Dropdown ---
        function toggleQueueDropdown() {
            const content = document.getElementById('queueDropdownContent');
            const chevron = document.getElementById('queueDropdownChevron');

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                chevron.classList.remove('rotated');
            } else {
                content.classList.add('expanded');
                chevron.classList.add('rotated');
                renderQueueList();
            }
        }

        function renderQueueList() {
            const list = document.getElementById('queueList');
            const queue = JSON.parse(localStorage.getItem('kv_queue') || '[]');

            if (!list) return;

            if (queue.length === 0) {
                list.innerHTML = '<p class="yt-queue-empty">Queue is empty. Add videos using the Queue button.</p>';
                return;
            }

            list.innerHTML = queue.map((item, index) => `
            <div class="yt-queue-item" onclick="window.location.href='/watch?v=${item.id}'">
                <img src="${item.thumbnail}" loading="lazy">
                <div class="yt-queue-item-info">
                    <div class="yt-queue-item-title">${escapeHtml(item.title)}</div>
                    <div class="yt-queue-item-uploader">${escapeHtml(item.uploader || 'Unknown')}</div>
                </div>
                <button class="yt-queue-remove-btn" onclick="event.stopPropagation(); removeFromQueueDropdown(${index})">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        `).join('');
        }

        function removeFromQueueDropdown(index) {
            let queue = JSON.parse(localStorage.getItem('kv_queue') || '[]');
            const removedItem = queue[index];
            queue.splice(index, 1);
            localStorage.setItem('kv_queue', JSON.stringify(queue));

            renderQueueList();
            updateQueueCount();
            updateQueueBadge();

            // Update Add/Remove Queue button state if looking at the removed video
            if (currentVideoData && removedItem && currentVideoData.id === removedItem.id) {
                updateQueueButtonState();
            }

            showToast("Removed from Queue", "info");
        }

        function updateQueueCount() {
            const countEl = document.getElementById('queueCount');
            if (countEl) {
                const queue = JSON.parse(localStorage.getItem('kv_queue') || '[]');
                countEl.innerText = queue.length;
            }
        }

        function updateQueueBadge() {
            const badge = document.getElementById('queueBadge');
            if (badge) {
                const queue = JSON.parse(localStorage.getItem('kv_queue') || '[]');
                if (queue.length > 0) {
                    badge.style.display = 'flex';
                    badge.innerText = queue.length;
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        function toggleDescription() {
            const desc = document.getElementById('videoDesc');
            desc.style.webkitLineClamp = desc.style.webkitLineClamp === 'unset' ? '3' : 'unset';
        }

        function toggleComments() {
            const content = document.getElementById('commentsContent');
            const chevron = document.getElementById('commentsChevron');
            const videoId = "{{ video_id }}";

            if (content.style.display === 'none') {
                content.style.display = 'block';
                chevron.classList.add('rotated');

                // Load comments only once
                if (!commentsLoaded) {
                    loadComments(videoId);
                    commentsLoaded = true;
                }
            } else {
                content.style.display = 'none';
                chevron.classList.remove('rotated');
            }
        }

        function saveToLocalHistory(item) {
            let history = JSON.parse(localStorage.getItem('kv_history') || '[]');
            // Remove existing if present (to move to top)
            history = history.filter(v => v.id !== item.id);
            // Add to front
            history.unshift(item);
            // Limit to 50
            if (history.length > 50) history.pop();
            localStorage.setItem('kv_history', JSON.stringify(history));
        }

        async function loadComments(videoId) {
            const commentsList = document.getElementById('commentsList');
            commentsList.innerHTML = Array(3).fill(0).map(() => `
            <div class="skeleton-comment">
                <div class="skeleton-comment-avatar skeleton"></div>
                <div class="skeleton-comment-body">
                    <div class="skeleton-line skeleton" style="width: 30%;"></div>
                    <div class="skeleton-line skeleton" style="width: 80%;"></div>
                    <div class="skeleton-line skeleton" style="width: 60%;"></div>
                </div>
            </div>
        `).join('');

            try {
                const response = await fetch(`/api/comments?v=${videoId}`);
                const data = await response.json();

                document.getElementById('commentCount').innerText = formatViews(data.count);
                document.getElementById('commentCountDisplay').innerText = `${formatViews(data.count)} Comments`;

                commentsList.innerHTML = '';

                if (data.comments && data.comments.length > 0) {
                    data.comments.forEach(comment => {
                        const commentEl = document.createElement('div');
                        commentEl.className = 'yt-comment';
                        commentEl.innerHTML = `
                        <div class="yt-comment-avatar">
                            ${comment.author_thumbnail
                                ? `<img src="${comment.author_thumbnail}" alt="">`
                                : escapeHtml(comment.author.charAt(0).toUpperCase())
                            }
                        </div>
                        <div class="yt-comment-content">
                            <div class="yt-comment-header">
                                ${comment.is_pinned ? '<span class="yt-pinned-badge">ðŸ“Œ Pinned</span>' : ''}
                                <span class="yt-comment-author">${escapeHtml(comment.author)}</span>
                                <span class="yt-comment-time">${comment.time || ''}</span>
                            </div>
                            <p class="yt-comment-text">${escapeHtml(comment.text)}</p>
                            <div class="yt-comment-actions">
                                <button class="yt-comment-action">
                                    <i class="fas fa-thumbs-up"></i>
                                    ${comment.likes > 0 ? formatViews(comment.likes) : ''}
                                </button>
                                <button class="yt-comment-action">
                                    <i class="fas fa-thumbs-down"></i>
                                </button>
                            </div>
                        </div>
                    `;
                        commentsList.appendChild(commentEl);
                    });
                } else {
                    commentsList.innerHTML = `<p class="yt-no-comments">Comments are disabled or unavailable for this video.</p>`;
                }
            } catch (e) {
                console.error('Error loading comments:', e);
                commentsList.innerHTML = `<p class="yt-no-comments">Could not load comments.</p>`;
            }
        }

        // Initialize Watch Page Logic
        (async function initWatchPage() {
            const videoType = "{{ video_type }}";
            const loading = document.getElementById('loading');
            const infoSkeleton = document.getElementById('infoSkeleton');
            const videoInfo = document.getElementById('videoInfo');
            const videoId = "{{ video_id }}";

            // If local video, init immediately
            if (videoType === 'local') {
                const player = initArtplayer("{{ src }}", "");
                document.getElementById('videoTitle').innerText = "{{ title }}";
                document.getElementById('channelName').innerText = "Local Video";
                document.getElementById('channelAvatarLetter').innerText = 'L';
                loading.style.display = 'none';
                if (infoSkeleton) infoSkeleton.style.display = 'none';
                videoInfo.style.display = 'block';
                document.getElementById('commentsSection').style.display = 'none';
                return;
            }

            // Retry Configuration
            const MAX_RETRIES = 2; // Try 3 times total
            let retryCount = 0;

            while (retryCount <= MAX_RETRIES) {
                try {
                    if (retryCount > 0) {
                        loading.innerHTML = `<div class="yt-loader-spinner"></div><p style="color:#fff; margin-top:10px;">Taking longer than expected... (Attempt ${retryCount + 1}/${MAX_RETRIES + 1})</p>`;
                    }

                    const response = await fetch(`/api/get_stream_info?v=${videoId}`);

                    if (response.status === 504) {
                        throw new Error("Server Timeout");
                    }

                    if (!response.ok) {
                        // If 500/502/etc, might be temporary
                        let errorMessage = `Server Error (${response.status})`;
                        try {
                            const errData = await response.json();
                            if (errData.error) errorMessage = errData.error;
                        } catch (e) { }
                        throw new Error(errorMessage);
                    }

                    // Success! Break loop
                    // ... (Proceed to process data)

                    // Check content type to avoid JSON syntax errors if HTML is returned
                    const contentType = response.headers.get("content-type");
                    if (!contentType || !contentType.includes("application/json")) {
                        throw new Error("Received invalid response from server");
                    }

                    // We need to break out of the while loop and continue below
                    // But we can just execute the rest here and return.
                    // Or assign data and break.
                    var data = await response.json();
                    break;

                } catch (e) {
                    console.warn(`Attempt ${retryCount + 1} failed:`, e);
                    retryCount++;
                    if (retryCount > MAX_RETRIES) {
                        loading.innerHTML = `<p style="color:#f00; text-align:center;">Failed to load video: ${e.message}</p><button onclick="location.reload()" style="margin-top:10px; padding:8px 16px; border-radius:18px; border:none; background:#3ea6ff; color:#fff; cursor:pointer;">Retry</button>`;
                        if (infoSkeleton) infoSkeleton.style.display = 'none';
                        showToast("Failed to load video.", "error");
                        return; // Exit
                    }
                    // Wait before retry (exponential backoff)
                    await new Promise(r => setTimeout(r, 1500 * retryCount));
                }
            }

            // --- Process Data (Success) ---
            // Existing logic to process 'data'
            if (!data) return; // Should not happen due to return in catch



            // Populate global data for Queue
            currentVideoData = {
                id: videoId,
                title: data.title,
                thumbnail: `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg`,
                uploader: data.uploader || 'Unknown',
                channel_id: data.channel_id || data.uploader_id || '',
                duration: data.duration,
                audioUrl: data.audio_url
            };

            // Check if video is already in queue
            updateQueueButtonState();
            updateQueueCount();
            updateQueueBadge();



            if (data.error) {
                loading.innerHTML = `<p style="color:#f00; text-align:center;">${data.error}</p>`;
                if (infoSkeleton) infoSkeleton.style.display = 'none';
                showToast(data.error, 'error');
                return;
            }

            const posterUrl = `https://i.ytimg.com/vi/${videoId}/maxresdefault.jpg`;

            // Determine video type
            let streamType = 'auto';
            if (data.original_url && (data.original_url.includes('.m3u8') || data.original_url.includes('manifest'))) {
                streamType = 'm3u8';
            }
            // Disable direct YouTube subtitle URL to prevent CORS errors
            // Use our server-side /api/transcript endpoint instead
            const player = initArtplayer(data.stream_url, posterUrl, '', streamType);
            window.player = player; // Ensure global access for loop button
            currentStreamUrl = data.stream_url; // For download button

            loading.style.display = 'none';
            if (infoSkeleton) infoSkeleton.style.display = 'none';
            videoInfo.style.display = 'block';

            const channelLink = data.uploader_id ? `/channel/${data.uploader_id}` : (data.channel_id ? `/channel/${data.channel_id}` : `/channel/${data.uploader || 'unknown'}`);

            document.getElementById('videoTitle').innerText = data.title || 'Untitled';

            const channelNameEl = document.getElementById('channelName');
            channelNameEl.innerHTML = `<a href="${channelLink}" style="color:inherit; text-decoration:none;">${data.uploader || 'Unknown'}</a>`;

            // Make avatar clickable too
            const avatarEl = document.getElementById('channelAvatar');
            avatarEl.style.cursor = 'pointer';
            avatarEl.onclick = () => window.location.href = channelLink;
            document.getElementById('viewCount').innerText = formatViews(data.view_count) + ' views';
            document.getElementById('videoDesc').innerText = data.description || 'No description';
            document.getElementById('descStats').innerText = `${formatViews(data.view_count)} views â€¢ ${data.upload_date || 'Recently'}`;
            document.getElementById('downloadBtn').href = data.stream_url;

            const uploaderName = data.uploader || 'Unknown';
            document.getElementById('channelAvatarLetter').innerText = uploaderName.charAt(0).toUpperCase();

            // Update subscribe button state based on stored subscriptions
            updateSubscribeButtonState();

            // Save to History (Local & Server)
            const historyItem = {
                id: videoId,
                title: data.title,
                thumbnail: `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg`,
                timestamp: new Date().toISOString(),
                uploader: data.uploader
            };

            // 1. Save Local
            saveToLocalHistory(historyItem);

            // 2. Save Server (if logged in - fail silently if 401/403)
            fetch('/api/save_video', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    id: videoId,
                    title: data.title,
                    thumbnail: `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg`,
                    type: 'history'
                })
            }).catch(() => { }); // Ignore errors for anon users



            // Save Button - Local Storage based
            // Save Button handler is setup in DOMContentLoaded below
            // Just update state here
            // document.getElementById('saveBtn').onclick setup moved to line ~1600

            // Check if already saved
            updateSaveButtonState();

            document.getElementById('shareBtn').onclick = () => {
                navigator.clipboard.writeText(window.location.href);
                showToast('Link copied to clipboard!', 'success');
            };

            // Related Videos
            // Related Videos
            const relatedContainer = document.getElementById('relatedVideos');
            // Clear but keep header
            relatedContainer.innerHTML = '<h3 style="margin-bottom: 16px; font-size: 16px;">Related Videos</h3>';

            if (data.related && data.related.length > 0) {
                renderRelated(data.related);
            } else {
                // No initial related videos, trigger load immediately on mobile
                relatedPage = 1; // Start from page 1
                setTimeout(() => loadMoreRelated(), 500);
            }

            // Add Sentinel for infinite scroll
            const sentinel = document.createElement('div');
            sentinel.id = 'relatedSentinel';
            sentinel.style.height = '20px';
            relatedContainer.appendChild(sentinel);

            // Setup Observer
            setupRelatedObserver();

            // Set global title for pagination
            currentVideoTitle = data.title;
            if (data.related && data.related.length > 0) {
                relatedPage = 2; // Next page is 2 if we had initial data
            }
        })(); // End initWatchPage IIFE

        function formatViews(views) {
            if (!views) return '0';
            const num = parseInt(views);
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(0) + 'K';
            return num.toLocaleString();
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }



        async function summarizeVideo() {
            const videoId = "{{ video_id }}";
            const btn = document.getElementById('summarizeBtn');
            const box = document.getElementById('summaryBox');
            const text = document.getElementById('summaryText');

            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';

            box.style.display = 'block';
            text.innerText = 'Analyzing transcript and extracting key insights...';

            try {
                const response = await fetch(`/api/summarize?v=${videoId}`);
                const data = await response.json();

                if (data.success) {
                    text.innerText = data.summary;
                } else {
                    text.innerText = data.message || 'Could not generate summary.';
                }
            } catch (e) {
                text.innerText = 'Network error during summarization.';
            }
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-magic"></i> Summarize with AI';
        }

        // --- Save Button Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) {
                // Check initial state
                if (isInLibrary('saved', currentVideoData.id)) {
                    saveBtn.innerHTML = '<i class="fas fa-bookmark"></i> Saved';
                    saveBtn.classList.add('active');
                }

                saveBtn.onclick = () => {
                    console.log("[Debug] Save Clicked. Current Data:", currentVideoData);

                    if (!currentVideoData || !currentVideoData.id) {
                        showToast("Error: Video data not ready yet", "error");
                        return;
                    }

                    // Ensure data is up to date
                    const titleEl = document.getElementById('videoTitle');
                    if (titleEl) currentVideoData.title = titleEl.innerText;
                    const uploaderEl = document.getElementById('channelName');
                    if (uploaderEl) currentVideoData.uploader = uploaderEl.innerText;

                    console.log("[Debug] Saving:", currentVideoData);

                    if (isInLibrary('saved', currentVideoData.id)) {
                        removeFromLibrary('saved', currentVideoData.id);
                        saveBtn.innerHTML = '<i class="far fa-bookmark"></i> Save';
                        saveBtn.classList.remove('active');
                    } else {
                        saveToLibrary('saved', currentVideoData);
                        saveBtn.innerHTML = '<i class="fas fa-bookmark"></i> Saved';
                        saveBtn.classList.add('active');
                    }
                };
            }

            // --- Subscribe Button Logic ---
            const subBtn = document.getElementById('subscribeBtn');
            if (subBtn) {
                const updateSubState = () => {
                    // Check against ID or Uploader name (fallback)
                    const key = currentVideoData.channel_id || currentVideoData.uploader;
                    if (!key) return;

                    if (isInLibrary('subscriptions', key)) {
                        subBtn.innerHTML = '<i class="fas fa-check-circle"></i> Subscribed';
                        subBtn.classList.add('subscribed');
                    } else {
                        subBtn.innerHTML = '<i class="fas fa-user-plus"></i> Subscribe';
                        subBtn.classList.remove('subscribed');
                    }
                };

                // Polling/Delay check as data populates
                setTimeout(updateSubState, 1000);
                setTimeout(updateSubState, 3000);

                subBtn.onclick = () => {
                    if (!currentVideoData.uploader) {
                        showToast("Channel data not ready", "error");
                        return;
                    }

                    // Capture avatar image or fallback to letter content
                    const avatarImg = document.querySelector('#channelAvatar img');
                    const avatarLetter = document.getElementById('channelAvatarLetter');

                    const channelItem = {
                        id: currentVideoData.channel_id || currentVideoData.uploader,
                        title: currentVideoData.uploader,
                        thumbnail: avatarImg ? avatarImg.src : '',
                        letter: avatarLetter ? avatarLetter.innerText : (currentVideoData.uploader[0] || '?'),
                        type: 'channel'
                    };

                    if (isInLibrary('subscriptions', channelItem.id)) {
                        removeFromLibrary('subscriptions', channelItem.id);
                        subBtn.innerHTML = '<i class="fas fa-user-plus"></i> Subscribe';
                        subBtn.classList.remove('subscribed');
                    } else {
                        saveToLibrary('subscriptions', channelItem);
                        subBtn.innerHTML = '<i class="fas fa-check-circle"></i> Subscribed';
                        subBtn.classList.add('subscribed');
                    }
                };
            }
        });

        // --- Related Videos Infinite Scroll Functions ---
        var currentVideoTitle = '';
        var relatedPage = 1;
        var relatedIsLoading = false;

        function setupRelatedObserver() {
            const observer = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting && !relatedIsLoading && currentVideoTitle) {
                    loadMoreRelated();
                }
            }, { rootMargin: '200px' });

            const sentinel = document.getElementById('relatedSentinel');
            if (sentinel) observer.observe(sentinel);
        }

        async function loadMoreRelated() {
            if (relatedIsLoading) return;
            relatedIsLoading = true;

            try {
                // Show mini loader
                const sentinel = document.getElementById('relatedSentinel');
                if (sentinel) sentinel.innerHTML = '<div class="loader" style="margin:0 auto; width:20px; height:20px;"></div>';

                const channel = currentVideoData?.channel_id || '';
                const uploader = currentVideoData?.uploader || '';
                const response = await fetch(`/api/related?title=${encodeURIComponent(currentVideoTitle)}&page=${relatedPage}&channel=${encodeURIComponent(channel)}&uploader=${encodeURIComponent(uploader)}`);
                const videos = await response.json();

                if (videos && videos.length > 0) {
                    renderRelated(videos);
                    relatedPage++;
                    if (sentinel) sentinel.innerHTML = ''; // Clear loader
                } else {
                    if (sentinel) sentinel.remove(); // Stop observing if no more data
                }
            } catch (e) {
                console.error("Failed to load related:", e);
            } finally {
                relatedIsLoading = false;
            }
        }

        function renderRelated(videos) {
            const container = document.getElementById('relatedVideos');
            const sentinel = document.getElementById('relatedSentinel'); // Insert before sentinel

            const fragment = document.createDocumentFragment();

            videos.forEach(video => {
                const card = document.createElement('div');
                card.className = 'yt-video-card-horizontal';
                card.onclick = () => window.location.href = `/watch?v=${video.id}`;
                card.innerHTML = `
                <div class="yt-thumb-container-h">
                   <img src="${video.thumbnail || 'https://i.ytimg.com/vi/' + video.id + '/mqdefault.jpg'}" loading="lazy" onerror="this.onerror=null; this.src='https://i.ytimg.com/vi/${video.id}/mqdefault.jpg'">
                   ${video.duration ? `<div class="yt-duration">${video.duration}</div>` : ''}
                </div>
                <div class="yt-details-h">
                   <div class="yt-title-h">${escapeHtml(video.title)}</div>
                   <div class="yt-meta-h">${escapeHtml(video.uploader || 'Unknown')}</div>
                   <div class="yt-meta-h">${formatViews(video.views)} â€¢ ${formatDate(video.uploaded)}</div>
                </div>
            `;
                fragment.appendChild(card);
            });

            if (sentinel) {
                container.insertBefore(fragment, sentinel);
            } else {
                container.appendChild(fragment); // Fallback
            }
        }
    </script>



    <!-- Download Modal -->
    <div id="downloadModal" class="download-modal" onclick="if(event.target===this) closeDownloadModal()">
        <div class="download-modal-content">
            <button class="download-close" onclick="closeDownloadModal()">
                <i class="fas fa-times"></i>
            </button>
            <div id="downloadModalContent">
                <!-- Content loaded dynamically -->
            </div>
        </div>
    </div>


    {% endblock %}